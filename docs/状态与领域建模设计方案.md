# VoxWorld 状态与领域建模设计方案

> 基于纲领文档的具体实现设计 - 实现基于状态的真实世界模拟

---

## 一、核心状态模型设计

### 1.1 ChunkData 扩展 - 从简单到复杂

```rust
// src/voxel/chunk.rs

/// Chunk 的核心数据结构（扩展版）
pub struct ChunkData {
    // === 基础数据（已有）===
    pub voxels: Vec<VoxelKind>,  // 16×16×16 = 4096 个方块类型
    pub is_dirty: bool,           // 脏标记

    // === 通用状态（轻量，全量）===
    pub flags: Vec<VoxelFlags>,      // 每个方块的状态标志位
    pub variant: Vec<u8>,            // 每个方块的变体/阶段（水位、结霜层数、生长阶段等）

    // === 专用状态（稀疏，按需分配）===
    pub thermal_state: Option<ThermalState>,       // 温度场（稀疏）
    pub moisture_state: Option<MoistureState>,     // 湿度场（稀疏）
    pub combustion_state: Option<CombustionState>, // 燃烧状态（稀疏）
    pub phase_state: Option<PhaseState>,           // 相变状态（稀疏）

    // === 活跃集合（驱动计算）===
    pub active_thermal: HashSet<usize>,     // 活跃的温度变化索引
    pub active_burning: HashSet<usize>,     // 正在燃烧的索引
    pub active_freezing: HashSet<usize>,    // 正在冻结的索引
    pub active_melting: HashSet<usize>,     // 正在融化的索引
    pub active_corroding: HashSet<usize>,   // 正在腐蚀的索引

    // === 渲染与同步（已有+扩展）===
    pub dirty_blocks: Vec<usize>,           // 变化的方块索引列表
    pub needs_remesh: bool,                 // 需要重建网格
    pub changes: Vec<BlockChange>,          // 变更日志（用于网络同步/存档）
}

/// 方块状态标志位（用 bitflags 实现）
bitflags! {
    pub struct VoxelFlags: u16 {
        const NONE = 0;

        // 燃烧相关
        const BURNING = 1 << 0;      // 正在燃烧
        const CHARRED = 1 << 1;      // 已焦化
        const SMOLDERING = 1 << 2;   // 闷烧中

        // 温度相关
        const HOT = 1 << 3;          // 高温（>100°C）
        const COLD = 1 << 4;         // 低温（<0°C）

        // 湿度相关
        const WET = 1 << 5;          // 潮湿
        const SOAKED = 1 << 6;       // 浸透
        const FROZEN = 1 << 7;       // 冻结

        // 状态相关
        const MELTING = 1 << 8;      // 融化中
        const EVAPORATING = 1 << 9;  // 蒸发中
        const CONDENSING = 1 << 10;  // 凝结中

        // 结构相关
        const DAMAGED = 1 << 11;     // 损坏
        const UNSTABLE = 1 << 12;    // 不稳定（将塌落）
        const CORRODED = 1 << 13;    // 腐蚀

        // 生物相关
        const GROWING = 1 << 14;     // 生长中
        const WITHERING = 1 << 15;   // 枯萎中
    }
}

/// 变更记录（用于 diff 同步）
#[derive(Clone, Debug)]
pub enum BlockChange {
    SetVoxel { idx: usize, old: VoxelKind, new: VoxelKind },
    SetFlag { idx: usize, flag: VoxelFlags, set: bool },
    SetVariant { idx: usize, old: u8, new: u8 },
    SetTemp { idx: usize, temp: f32 },
    SetMoisture { idx: usize, moisture: f32 },
}
```

### 1.2 领域状态定义 - 稀疏存储

```rust
// src/voxel/domains/thermal.rs

/// 温度场状态（稀疏存储）
pub struct ThermalState {
    /// 温度覆盖值（只存储偏离默认值的方块）
    /// 默认值从 BlockDef.properties.temperature 获取
    pub temp_overrides: HashMap<usize, f32>,

    /// 热能缓冲（用于扩散计算）
    pub heat_buffer: HashMap<usize, f32>,
}

// src/voxel/domains/moisture.rs

/// 湿度场状态（稀疏存储）
pub struct MoistureState {
    /// 湿度覆盖值（0.0-1.0）
    pub moisture_overrides: HashMap<usize, f32>,

    /// 湿度变化速率（用于扩散/蒸发）
    pub moisture_delta: HashMap<usize, f32>,
}

// src/voxel/domains/combustion.rs

/// 燃烧状态（稀疏存储）
pub struct CombustionState {
    /// 燃烧状态详情
    pub burn_states: HashMap<usize, BurnState>,
}

#[derive(Clone, Debug)]
pub struct BurnState {
    pub fuel_left: f32,       // 剩余燃料（0.0-1.0）
    pub intensity: f32,       // 燃烧强度（0.0-1.0）
    pub ignition_time: f32,   // 点燃时间（秒）
    pub heat_release: f32,    // 每秒释放的热量
}

// src/voxel/domains/phase.rs

/// 相变状态（稀疏存储）
pub struct PhaseState {
    /// 相变进度（0.0-1.0）
    pub phase_progress: HashMap<usize, f32>,

    /// 相变类型
    pub phase_type: HashMap<usize, PhaseTransition>,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum PhaseTransition {
    Melting,      // 固→液
    Freezing,     // 液→固
    Evaporating,  // 液→气
    Condensing,   // 气→液
    Sublimating,  // 固→气
}
```

---

## 二、BlockDef 扩展 - 物理属性表

### 2.1 完整的 VoxelProperties 定义

```rust
// src/voxel/voxel_kind.rs

/// 体素物理属性（扩展版）
pub struct VoxelProperties {
    // === 热学属性 ===
    pub temperature: f32,          // 默认温度（摄氏度）
    pub heat_capacity: f32,        // 热容（J/K）
    pub thermal_conductivity: f32, // 导热系数（W/m·K）
    pub env_exchange_coef: f32,    // 环境热交换系数

    // === 湿度属性 ===
    pub humidity: f32,             // 默认湿度（0.0-1.0）
    pub moisture_capacity: f32,    // 吸湿能力
    pub evaporation_rate: f32,     // 蒸发速率

    // === 燃烧属性 ===
    pub is_flammable: bool,        // 是否可燃
    pub ignition_temp: f32,        // 着火点（°C）
    pub burn_energy: f32,          // 总燃烧能量
    pub burn_rate: f32,            // 燃烧速率（1/秒）
    pub heat_release: f32,         // 热释放率（W）
    pub char_block: Option<VoxelKind>,  // 焦化后变成的方块
    pub ash_block: Option<VoxelKind>,   // 灰化后变成的方块

    // === 相变属性 ===
    pub melting_point: Option<f32>,     // 熔点（°C）
    pub freezing_point: Option<f32>,    // 冰点（°C）
    pub boiling_point: Option<f32>,     // 沸点（°C）
    pub liquid_form: Option<VoxelKind>, // 液态形式
    pub solid_form: Option<VoxelKind>,  // 固态形式
    pub gas_form: Option<VoxelKind>,    // 气态形式

    // === 结构属性 ===
    pub hardness: f32,             // 硬度（破坏难度）
    pub ductility: f32,            // 延展性（变形能力）
    pub integrity: f32,            // 结构完整性（0.0-1.0）
    pub corrosion_resistance: f32, // 抗腐蚀性（0.0-1.0）

    // === 生长属性（植物）===
    pub is_growable: bool,         // 是否可生长
    pub growth_rate: f32,          // 生长速率
    pub max_growth_stage: u8,      // 最大生长阶段
}

impl VoxelKind {
    /// 获取物理属性（工厂方法）
    pub fn properties(&self) -> VoxelProperties {
        match self {
            VoxelKind::Air => VoxelProperties {
                temperature: 20.0,
                heat_capacity: 1.0,
                thermal_conductivity: 0.026,
                env_exchange_coef: 0.0,
                humidity: 0.5,
                is_flammable: false,
                // ... 其他默认值
            },

            VoxelKind::OakLog => VoxelProperties {
                temperature: 20.0,
                heat_capacity: 1700.0,      // 木材热容
                thermal_conductivity: 0.12,  // 木材导热系数
                env_exchange_coef: 0.05,
                humidity: 0.12,              // 12% 含水率
                is_flammable: true,
                ignition_temp: 300.0,        // 木材着火点约 300°C
                burn_energy: 100.0,
                burn_rate: 0.2,
                heat_release: 200.0,
                char_block: Some(VoxelKind::CharredOakLog), // 需要新增
                ash_block: Some(VoxelKind::Ash),           // 需要新增
                hardness: 2.0,
                corrosion_resistance: 0.3,
                // ...
            },

            VoxelKind::Water => VoxelProperties {
                temperature: 15.0,
                heat_capacity: 4186.0,       // 水的比热容
                thermal_conductivity: 0.6,
                humidity: 1.0,               // 100% 湿度
                is_flammable: false,
                freezing_point: Some(0.0),   // 冰点 0°C
                boiling_point: Some(100.0),  // 沸点 100°C
                solid_form: Some(VoxelKind::Ice),
                gas_form: Some(VoxelKind::Air), // 简化：蒸汽→空气
                // ...
            },

            VoxelKind::Ice => VoxelProperties {
                temperature: -5.0,
                heat_capacity: 2090.0,       // 冰的比热容
                thermal_conductivity: 2.22,  // 冰的导热系数
                humidity: 0.0,
                melting_point: Some(0.0),
                liquid_form: Some(VoxelKind::Water),
                hardness: 0.5,
                // ...
            },

            // ... 其他 33 种方块的属性定义

            _ => VoxelProperties::default(),
        }
    }
}
```

---

## 三、领域模块化架构

### 3.1 领域模块模板

每个领域模块遵循统一的结构：

```
src/voxel/domains/
├── mod.rs                # 模块导出
├── thermal/
│   ├── mod.rs            # 模块入口
│   ├── state.rs          # ThermalState 定义
│   ├── systems.rs        # 热扩散、冷却系统
│   ├── api.rs            # get_temp, set_temp, add_heat 等
│   └── plugin.rs         # ThermalPlugin（Bevy 集成）
├── moisture/
│   ├── mod.rs
│   ├── state.rs          # MoistureState
│   ├── systems.rs        # 湿度扩散、蒸发系统
│   ├── api.rs
│   └── plugin.rs
├── combustion/
│   ├── mod.rs
│   ├── state.rs          # CombustionState
│   ├── systems.rs        # 燃烧 tick、传播系统
│   ├── api.rs
│   └── plugin.rs
├── phase/
│   ├── mod.rs
│   ├── state.rs          # PhaseState
│   ├── systems.rs        # 相变判定系统
│   ├── api.rs
│   └── plugin.rs
└── reaction/
    ├── mod.rs
    ├── rules.rs          # 反应规则定义
    ├── commands.rs       # 命令类型定义
    └── commit.rs         # 统一提交系统
```

### 3.2 领域 API 设计示例

```rust
// src/voxel/domains/thermal/api.rs

/// 热力学领域 API
pub struct ThermalApi;

impl ThermalApi {
    /// 获取方块温度（考虑默认值和覆盖值）
    pub fn get_temp(chunk: &ChunkData, idx: usize) -> f32 {
        if let Some(thermal) = &chunk.thermal_state {
            if let Some(&temp) = thermal.temp_overrides.get(&idx) {
                return temp;
            }
        }
        // 回退到默认值
        chunk.voxels[idx].properties().temperature
    }

    /// 设置方块温度（会激活到活跃集合）
    pub fn set_temp(chunk: &mut ChunkData, idx: usize, temp: f32) {
        // 延迟分配稀疏状态
        let thermal = chunk.thermal_state.get_or_insert_with(ThermalState::default);

        let default_temp = chunk.voxels[idx].properties().temperature;
        if (temp - default_temp).abs() > 0.1 {
            thermal.temp_overrides.insert(idx, temp);
            chunk.active_thermal.insert(idx);
        } else {
            thermal.temp_overrides.remove(&idx);
            // 如果回到默认值，可能需要从活跃集合移除
            if !Self::should_stay_active(chunk, idx) {
                chunk.active_thermal.remove(&idx);
            }
        }

        // 记录变更
        chunk.changes.push(BlockChange::SetTemp { idx, temp });
        chunk.dirty_blocks.push(idx);
    }

    /// 添加热量（用于燃烧、传导等）
    pub fn add_heat(chunk: &mut ChunkData, idx: usize, heat: f32) {
        let current_temp = Self::get_temp(chunk, idx);
        let heat_capacity = chunk.voxels[idx].properties().heat_capacity;
        let delta_temp = heat / heat_capacity;
        Self::set_temp(chunk, idx, current_temp + delta_temp);
    }

    /// 判断是否应保持活跃
    fn should_stay_active(chunk: &ChunkData, idx: usize) -> bool {
        // 如果温度与默认值差异大，保持活跃
        // 如果是燃烧源附近，保持活跃
        // 如果周围有温度梯度，保持活跃
        // ...
        false // 简化示例
    }
}

// src/voxel/domains/combustion/api.rs

/// 燃烧领域 API
pub struct CombustionApi;

impl CombustionApi {
    /// 点燃方块
    pub fn ignite(chunk: &mut ChunkData, idx: usize, power: f32) -> bool {
        let props = chunk.voxels[idx].properties();

        // 检查是否可燃
        if !props.is_flammable {
            return false;
        }

        // 检查湿度是否过高（需要跨域读取）
        let moisture = MoistureApi::get_moisture(chunk, idx);
        if moisture > 0.8 {
            return false; // 太湿，无法点燃
        }

        // 创建燃烧状态
        let combustion = chunk.combustion_state.get_or_insert_with(CombustionState::default);
        combustion.burn_states.insert(idx, BurnState {
            fuel_left: 1.0,
            intensity: power.min(1.0),
            ignition_time: 0.0, // 应从游戏时间获取
            heat_release: props.heat_release,
        });

        // 设置标志位
        chunk.flags[idx].insert(VoxelFlags::BURNING);
        chunk.active_burning.insert(idx);

        // 记录变更
        chunk.changes.push(BlockChange::SetFlag {
            idx,
            flag: VoxelFlags::BURNING,
            set: true,
        });
        chunk.dirty_blocks.push(idx);
        chunk.needs_remesh = true;

        true
    }

    /// 熄灭方块
    pub fn extinguish(chunk: &mut ChunkData, idx: usize) {
        // 移除燃烧状态
        if let Some(combustion) = &mut chunk.combustion_state {
            combustion.burn_states.remove(&idx);
        }

        chunk.flags[idx].remove(VoxelFlags::BURNING);
        chunk.active_burning.remove(&idx);

        chunk.changes.push(BlockChange::SetFlag {
            idx,
            flag: VoxelFlags::BURNING,
            set: false,
        });
        chunk.dirty_blocks.push(idx);
    }
}
```

---

## 四、Reaction/Command 系统

### 4.1 命令类型定义

```rust
// src/voxel/domains/reaction/commands.rs

/// 统一的领域命令（跨域交互的唯一方式）
#[derive(Clone, Debug)]
pub enum DomainCommand {
    // === 方块操作 ===
    SetBlock { idx: usize, new_voxel: VoxelKind },

    // === 标志位操作 ===
    AddFlag { idx: usize, flag: VoxelFlags },
    RemoveFlag { idx: usize, flag: VoxelFlags },

    // === 变体操作 ===
    SetVariant { idx: usize, variant: u8 },
    IncrementVariant { idx: usize },
    DecrementVariant { idx: usize },

    // === 热力学操作 ===
    SetTemp { idx: usize, temp: f32 },
    AddHeat { idx: usize, heat: f32 },

    // === 湿度操作 ===
    SetMoisture { idx: usize, moisture: f32 },
    AddMoisture { idx: usize, delta: f32 },

    // === 燃烧操作 ===
    Ignite { idx: usize, power: f32 },
    Extinguish { idx: usize },

    // === 相变操作 ===
    StartPhaseTransition { idx: usize, phase: PhaseTransition },
    CompletePhaseTransition { idx: usize },

    // === 结构操作 ===
    Damage { idx: usize, amount: f32 },
    Collapse { idx: usize },

    // === 生长操作 ===
    Grow { idx: usize },
    Wither { idx: usize },
}

/// 命令队列（每个 Chunk 一个）
#[derive(Component)]
pub struct CommandQueue {
    pub commands: Vec<DomainCommand>,
}
```

### 4.2 反应规则系统

```rust
// src/voxel/domains/reaction/rules.rs

/// 反应规则特征
pub trait ReactionRule: Send + Sync {
    /// 判断是否触发（读取状态）
    fn evaluate(&self, chunk: &ChunkData, idx: usize) -> bool;

    /// 产生命令（不修改状态）
    fn emit_commands(&self, chunk: &ChunkData, idx: usize) -> Vec<DomainCommand>;
}

/// 示例：温度点燃规则
pub struct ThermalIgnitionRule;

impl ReactionRule for ThermalIgnitionRule {
    fn evaluate(&self, chunk: &ChunkData, idx: usize) -> bool {
        let props = chunk.voxels[idx].properties();

        // 条件：可燃 + 未燃烧 + 温度超过着火点
        props.is_flammable
            && !chunk.flags[idx].contains(VoxelFlags::BURNING)
            && ThermalApi::get_temp(chunk, idx) >= props.ignition_temp
    }

    fn emit_commands(&self, chunk: &ChunkData, idx: usize) -> Vec<DomainCommand> {
        vec![DomainCommand::Ignite { idx, power: 1.0 }]
    }
}

/// 示例：水冻结规则
pub struct FreezingRule;

impl ReactionRule for FreezingRule {
    fn evaluate(&self, chunk: &ChunkData, idx: usize) -> bool {
        chunk.voxels[idx] == VoxelKind::Water
            && ThermalApi::get_temp(chunk, idx) <= 0.0
            && !chunk.flags[idx].contains(VoxelFlags::FROZEN)
    }

    fn emit_commands(&self, chunk: &ChunkData, idx: usize) -> Vec<DomainCommand> {
        vec![
            DomainCommand::StartPhaseTransition {
                idx,
                phase: PhaseTransition::Freezing,
            },
        ]
    }
}

/// 示例：冰融化规则
pub struct MeltingRule;

impl ReactionRule for MeltingRule {
    fn evaluate(&self, chunk: &ChunkData, idx: usize) -> bool {
        chunk.voxels[idx] == VoxelKind::Ice
            && ThermalApi::get_temp(chunk, idx) > 0.0
    }

    fn emit_commands(&self, chunk: &ChunkData, idx: usize) -> Vec<DomainCommand> {
        vec![
            DomainCommand::StartPhaseTransition {
                idx,
                phase: PhaseTransition::Melting,
            },
        ]
    }
}

/// 反应规则注册表（全局资源）
#[derive(Resource)]
pub struct ReactionRules {
    pub rules: Vec<Box<dyn ReactionRule>>,
}

impl Default for ReactionRules {
    fn default() -> Self {
        Self {
            rules: vec![
                Box::new(ThermalIgnitionRule),
                Box::new(FreezingRule),
                Box::new(MeltingRule),
                // ... 更多规则
            ],
        }
    }
}
```

### 4.3 统一 Commit 系统

```rust
// src/voxel/domains/reaction/commit.rs

/// 提交阶段：统一执行所有命令
pub fn commit_commands(chunk: &mut ChunkData, commands: Vec<DomainCommand>) {
    // 命令去重与冲突处理
    let resolved = resolve_conflicts(commands);

    for cmd in resolved {
        match cmd {
            DomainCommand::SetBlock { idx, new_voxel } => {
                let old = chunk.voxels[idx];
                chunk.voxels[idx] = new_voxel;
                chunk.changes.push(BlockChange::SetVoxel {
                    idx,
                    old,
                    new: new_voxel,
                });
                chunk.dirty_blocks.push(idx);
                chunk.needs_remesh = true;
            }

            DomainCommand::AddFlag { idx, flag } => {
                chunk.flags[idx].insert(flag);
                chunk.changes.push(BlockChange::SetFlag { idx, flag, set: true });
                chunk.dirty_blocks.push(idx);
            }

            DomainCommand::RemoveFlag { idx, flag } => {
                chunk.flags[idx].remove(flag);
                chunk.changes.push(BlockChange::SetFlag { idx, flag, set: false });
                chunk.dirty_blocks.push(idx);
            }

            DomainCommand::SetTemp { idx, temp } => {
                ThermalApi::set_temp(chunk, idx, temp);
            }

            DomainCommand::AddHeat { idx, heat } => {
                ThermalApi::add_heat(chunk, idx, heat);
            }

            DomainCommand::Ignite { idx, power } => {
                CombustionApi::ignite(chunk, idx, power);
            }

            DomainCommand::Extinguish { idx } => {
                CombustionApi::extinguish(chunk, idx);
            }

            DomainCommand::StartPhaseTransition { idx, phase } => {
                PhaseApi::start_transition(chunk, idx, phase);
            }

            // ... 其他命令的执行
        }
    }
}

/// 冲突解决策略
fn resolve_conflicts(commands: Vec<DomainCommand>) -> Vec<DomainCommand> {
    use std::collections::HashMap;

    // 按 idx 分组
    let mut per_idx: HashMap<usize, Vec<DomainCommand>> = HashMap::new();
    for cmd in commands {
        let idx = match &cmd {
            DomainCommand::SetBlock { idx, .. } => *idx,
            DomainCommand::AddFlag { idx, .. } => *idx,
            DomainCommand::SetTemp { idx, .. } => *idx,
            DomainCommand::Ignite { idx, .. } => *idx,
            // ...
            _ => continue,
        };
        per_idx.entry(idx).or_default().push(cmd);
    }

    // 优先级处理
    let mut resolved = Vec::new();
    for (_idx, cmds) in per_idx {
        // 示例：SetBlock 优先级最高
        if let Some(set_block) = cmds.iter().find(|c| matches!(c, DomainCommand::SetBlock { .. })) {
            resolved.push(set_block.clone());
            continue;
        }

        // 其他命令按顺序执行
        resolved.extend(cmds);
    }

    resolved
}
```

---

## 五、系统调度管线

### 5.1 SystemSet 定义

```rust
// src/voxel/domains/mod.rs

/// 固定的系统执行顺序
#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
pub enum SimulationSet {
    /// 1. 外部输入（玩家、脚本、网络）
    ExternalActions,

    /// 2. 连续场更新（扩散、传导）
    FieldUpdate,

    /// 3. 离散状态更新（燃烧 tick、生长 tick）
    StateUpdate,

    /// 4. 反应规则判定（产生命令）
    Reactions,

    /// 5. 统一提交（执行命令、写回状态）
    Commit,

    /// 6. 后处理（清理、打包 diff、渲染）
    Post,
}

// src/voxel/plugin.rs

impl Plugin for VoxelPlugin {
    fn build(&self, app: &mut App) {
        app
            // 配置系统集顺序
            .configure_sets(
                FixedUpdate,
                (
                    SimulationSet::ExternalActions,
                    SimulationSet::FieldUpdate,
                    SimulationSet::StateUpdate,
                    SimulationSet::Reactions,
                    SimulationSet::Commit,
                    SimulationSet::Post,
                ).chain()
            )

            // 注册资源
            .init_resource::<VoxelWorld>()
            .init_resource::<ReactionRules>()

            // 注册领域插件
            .add_plugins((
                ThermalPlugin,
                MoisturePlugin,
                CombustionPlugin,
                PhasePlugin,
            ))

            // 注册反应与提交系统
            .add_systems(FixedUpdate, (
                reaction_emit_system.in_set(SimulationSet::Reactions),
                commit_system.in_set(SimulationSet::Commit),
                cleanup_system.in_set(SimulationSet::Post),
            ));
    }
}
```

### 5.2 领域系统示例

```rust
// src/voxel/domains/thermal/systems.rs

/// 热扩散系统（FieldUpdate 阶段）
pub fn thermal_diffusion_system(
    mut voxel_world: ResMut<VoxelWorld>,
    time: Res<Time>,
) {
    let dt = time.delta_secs();

    for chunk in voxel_world.chunks.values_mut() {
        // 只处理活跃的温度索引
        let active_indices: Vec<usize> = chunk.active_thermal.iter().copied().collect();

        for &idx in &active_indices {
            let current_temp = ThermalApi::get_temp(chunk, idx);
            let props = chunk.voxels[idx].properties();

            // 计算扩散
            let mut heat_delta = 0.0;

            // 对 6 个相邻方块
            for neighbor_idx in get_neighbors(idx) {
                if neighbor_idx >= chunk.voxels.len() {
                    continue; // 跨 chunk 边界（需要特殊处理）
                }

                let neighbor_temp = ThermalApi::get_temp(chunk, neighbor_idx);
                let neighbor_props = chunk.voxels[neighbor_idx].properties();

                // 热传导公式：Q = k * A * ΔT / d
                let k_avg = (props.thermal_conductivity + neighbor_props.thermal_conductivity) / 2.0;
                let delta_t = neighbor_temp - current_temp;
                let heat_flow = k_avg * delta_t * dt;

                heat_delta += heat_flow;
            }

            // 环境热交换（边界条件）
            let env_temp = 20.0; // 环境温度
            heat_delta += props.env_exchange_coef * (env_temp - current_temp) * dt;

            // 应用热量变化
            if heat_delta.abs() > 0.01 {
                ThermalApi::add_heat(chunk, idx, heat_delta);
            } else {
                // 温度稳定，可以从活跃集合移除
                chunk.active_thermal.remove(&idx);
            }
        }
    }
}

// src/voxel/domains/combustion/systems.rs

/// 燃烧 tick 系统（StateUpdate 阶段）
pub fn combustion_tick_system(
    mut voxel_world: ResMut<VoxelWorld>,
    time: Res<Time>,
    mut command_queues: Query<&mut CommandQueue>,
) {
    let dt = time.delta_secs();

    for (chunk_pos, chunk) in voxel_world.chunks.iter_mut() {
        let burning_indices: Vec<usize> = chunk.active_burning.iter().copied().collect();

        for &idx in &burning_indices {
            let props = chunk.voxels[idx].properties();

            if let Some(combustion) = &mut chunk.combustion_state {
                if let Some(burn_state) = combustion.burn_states.get_mut(&idx) {
                    // 消耗燃料
                    burn_state.fuel_left -= props.burn_rate * burn_state.intensity * dt;
                    burn_state.ignition_time += dt;

                    // 释放热量（产生命令）
                    let heat_released = burn_state.heat_release * burn_state.intensity * dt;

                    // 向周围传播热量（命令列表）
                    let mut commands = vec![
                        DomainCommand::AddHeat { idx, heat: heat_released },
                    ];

                    for neighbor_idx in get_neighbors(idx) {
                        if neighbor_idx >= chunk.voxels.len() {
                            continue;
                        }

                        // 辐射热量到邻居
                        commands.push(DomainCommand::AddHeat {
                            idx: neighbor_idx,
                            heat: heat_released * 0.2, // 20% 辐射给邻居
                        });
                    }

                    // 燃料耗尽处理
                    if burn_state.fuel_left <= 0.0 {
                        commands.push(DomainCommand::Extinguish { idx });

                        // 变成焦炭或灰烬
                        if let Some(char_block) = props.char_block {
                            commands.push(DomainCommand::SetBlock {
                                idx,
                                new_voxel: char_block,
                            });
                        }
                    }

                    // 提交命令到队列（延迟到 Commit 阶段执行）
                    if let Ok(mut queue) = command_queues.get_single_mut() {
                        queue.commands.extend(commands);
                    }
                }
            }
        }
    }
}

// src/voxel/domains/reaction/systems.rs

/// 反应规则判定系统（Reactions 阶段）
pub fn reaction_emit_system(
    voxel_world: Res<VoxelWorld>,
    rules: Res<ReactionRules>,
    mut command_queues: Query<&mut CommandQueue>,
) {
    let mut all_commands = Vec::new();

    for chunk in voxel_world.chunks.values() {
        // 对所有活跃集合的并集
        let mut active_union: HashSet<usize> = HashSet::new();
        active_union.extend(&chunk.active_thermal);
        active_union.extend(&chunk.active_burning);
        active_union.extend(&chunk.active_freezing);
        active_union.extend(&chunk.active_melting);

        for &idx in &active_union {
            // 评估所有规则
            for rule in &rules.rules {
                if rule.evaluate(chunk, idx) {
                    all_commands.extend(rule.emit_commands(chunk, idx));
                }
            }
        }
    }

    // 提交到命令队列
    if let Ok(mut queue) = command_queues.get_single_mut() {
        queue.commands.extend(all_commands);
    }
}

/// 统一提交系统（Commit 阶段）
pub fn commit_system(
    mut voxel_world: ResMut<VoxelWorld>,
    mut command_queues: Query<&mut CommandQueue>,
) {
    if let Ok(mut queue) = command_queues.get_single_mut() {
        let commands = std::mem::take(&mut queue.commands);

        // 按 chunk 分组（简化示例）
        for chunk in voxel_world.chunks.values_mut() {
            commit_commands(chunk, commands.clone());
        }
    }
}
```

---

## 六、多样玩法的实现示例

### 6.1 玩法 1：火灾传播与消防

**状态驱动：**
- 燃烧状态（BurnState）
- 温度场（ThermalState）
- 湿度场（MoistureState）

**玩法机制：**
1. 玩家可以点燃方块（火把、打火石）
2. 火焰通过热辐射点燃周围可燃物
3. 玩家可以用水桶灭火（提高湿度）
4. 建筑材料选择影响防火性能
5. 烧毁后留下焦炭和灰烬

**实现：**
```rust
// 玩家点火输入（ExternalActions 阶段）
pub fn player_ignite_system(
    keyboard: Res<ButtonInput<KeyCode>>,
    raycast: Res<HighlightState>,
    mut commands: Query<&mut CommandQueue>,
) {
    if keyboard.just_pressed(KeyCode::KeyF) {
        if let Some(hit) = &raycast.current {
            if let Ok(mut queue) = commands.get_single_mut() {
                queue.commands.push(DomainCommand::Ignite {
                    idx: pos_to_idx(hit.pos),
                    power: 1.0,
                });
            }
        }
    }
}

// 玩家灭火输入
pub fn player_extinguish_system(
    keyboard: Res<ButtonInput<KeyCode>>,
    raycast: Res<HighlightState>,
    mut commands: Query<&mut CommandQueue>,
) {
    if keyboard.just_pressed(KeyCode::KeyG) {
        if let Some(hit) = &raycast.current {
            let idx = pos_to_idx(hit.pos);
            if let Ok(mut queue) = commands.get_single_mut() {
                queue.commands.extend(vec![
                    DomainCommand::Extinguish { idx },
                    DomainCommand::SetMoisture { idx, moisture: 1.0 },
                ]);
            }
        }
    }
}
```

### 6.2 玩法 2：冰雪世界与融化

**状态驱动：**
- 相变状态（PhaseState）
- 温度场（ThermalState）
- Frozen、Melting 标志位

**玩法机制：**
1. 水在低温下冻结成冰
2. 冰在高温下融化成水
3. 玩家可以放置火源加速融化
4. 雪地生物群系自然低温

**实现：**
```rust
// 相变进度更新（StateUpdate 阶段）
pub fn phase_progress_system(
    mut voxel_world: ResMut<VoxelWorld>,
    time: Res<Time>,
    mut commands: Query<&mut CommandQueue>,
) {
    let dt = time.delta_secs();

    for chunk in voxel_world.chunks.values_mut() {
        if let Some(phase) = &mut chunk.phase_state {
            for (&idx, progress) in phase.phase_progress.iter_mut() {
                *progress += dt * 0.1; // 10 秒完成相变

                if *progress >= 1.0 {
                    // 完成相变
                    if let Ok(mut queue) = commands.get_single_mut() {
                        queue.commands.push(DomainCommand::CompletePhaseTransition { idx });
                    }
                }
            }
        }
    }
}
```

### 6.3 玩法 3：植物生长系统

**状态驱动：**
- variant（生长阶段）
- Growing 标志位
- 温度、湿度环境条件

**玩法机制：**
1. 种子在合适条件下生长
2. 生长速度受温度、湿度影响
3. 成熟后可收获
4. 缺水或极端温度会枯萎

**实现：**
```rust
// 生长规则
pub struct GrowthRule;

impl ReactionRule for GrowthRule {
    fn evaluate(&self, chunk: &ChunkData, idx: usize) -> bool {
        let props = chunk.voxels[idx].properties();

        if !props.is_growable {
            return false;
        }

        // 检查环境条件
        let temp = ThermalApi::get_temp(chunk, idx);
        let moisture = MoistureApi::get_moisture(chunk, idx);

        // 适宜温度 10-30°C，湿度 > 0.3
        temp >= 10.0 && temp <= 30.0 && moisture > 0.3
    }

    fn emit_commands(&self, chunk: &ChunkData, idx: usize) -> Vec<DomainCommand> {
        let current_stage = chunk.variant[idx];
        let max_stage = chunk.voxels[idx].properties().max_growth_stage;

        if current_stage < max_stage {
            vec![
                DomainCommand::AddFlag { idx, flag: VoxelFlags::GROWING },
                DomainCommand::IncrementVariant { idx },
            ]
        } else {
            vec![]
        }
    }
}
```

### 6.4 玩法 4：腐蚀与锈蚀

**状态驱动：**
- corrosion_level（腐蚀程度）
- Corroded 标志位
- 湿度场（加速腐蚀）

**玩法机制：**
1. 金属在潮湿环境下生锈
2. 腐蚀降低结构完整性
3. 严重腐蚀导致崩塌
4. 玩家可以涂防锈涂层

### 6.5 玩法 5：建筑结构稳定性

**状态驱动：**
- integrity（结构完整性）
- Unstable、Damaged 标志位
- 力学传导（类似热扩散）

**玩法机制：**
1. 无支撑的方块会掉落
2. 燃烧/腐蚀降低完整性
3. 连锁崩塌效果
4. 玩家需要设计合理的支撑结构

---

## 七、实现路线图

### Phase 1：基础状态系统（2-3 周）

1. **扩展 ChunkData**
   - 添加 `flags`、`variant`、`dirty_blocks`、`changes`
   - 实现 `VoxelFlags` bitflags
   - 实现 `BlockChange` 枚举

2. **扩展 VoxelProperties**
   - 为 33 种方块定义完整物理属性
   - 重点：热学、燃烧、相变属性

3. **命令系统**
   - 实现 `DomainCommand` 枚举
   - 实现 `CommandQueue` 组件
   - 实现基础 `commit_system`

4. **测试**
   - 单元测试：flags、variant、commands
   - 集成测试：简单的 SetBlock 命令流

### Phase 2：热力学领域（2 周）

1. **ThermalState**
   - 稀疏温度存储
   - 活跃集合管理

2. **ThermalApi**
   - get_temp、set_temp、add_heat

3. **系统实现**
   - thermal_diffusion_system（扩散）
   - thermal_cooling_system（冷却）

4. **测试**
   - 热扩散模拟
   - 可视化：温度场颜色映射

### Phase 3：燃烧领域（2 周）

1. **CombustionState**
   - BurnState 定义
   - 活跃燃烧集合

2. **CombustionApi**
   - ignite、extinguish

3. **系统实现**
   - combustion_tick_system
   - combustion_spread_system

4. **反应规则**
   - ThermalIgnitionRule
   - BurnoutRule

5. **玩法集成**
   - 玩家点火/灭火输入
   - 火焰粒子效果（VFX）

### Phase 4：相变领域（1-2 周）

1. **PhaseState**
   - 相变进度跟踪
   - 相变类型枚举

2. **系统实现**
   - phase_progress_system
   - phase_complete_system

3. **反应规则**
   - FreezingRule、MeltingRule
   - EvaporatingRule

### Phase 5：湿度领域（1 周）

1. **MoistureState**
   - 稀疏湿度存储

2. **系统实现**
   - moisture_diffusion_system
   - evaporation_system

3. **规则集成**
   - 湿度影响燃烧
   - 湿度影响生长

### Phase 6：高级玩法（3-4 周）

1. **植物生长系统**
2. **结构稳定性系统**
3. **腐蚀系统**
4. **天气系统（降雨、降雪）**

### Phase 7：性能优化（2 周）

1. **跨 Chunk 边界处理**
2. **多线程并行处理**
3. **稀疏数据结构优化**
4. **活跃集合动态调整**

### Phase 8：MMO 集成（3 周）

1. **Diff 同步协议**
2. **网络打包与应用**
3. **客户端预测**
4. **存档压缩**

---

## 八、关键技术挑战与解决方案

### 8.1 跨 Chunk 边界处理

**挑战：**
- 扩散、燃烧传播需要访问相邻 Chunk
- 相邻 Chunk 可能未加载

**解决方案：**
```rust
// 边界缓存（每个 Chunk 缓存邻居边界数据）
pub struct ChunkBoundaryCache {
    pub neighbors: HashMap<Direction, Vec<VoxelKind>>, // 6 个方向
    pub neighbor_flags: HashMap<Direction, Vec<VoxelFlags>>,
}

// 扩散时先检查缓存
fn diffuse_to_neighbor(
    chunk: &mut ChunkData,
    idx: usize,
    direction: Direction,
    cache: &ChunkBoundaryCache,
) {
    if let Some(neighbor_data) = cache.neighbors.get(&direction) {
        // 使用缓存的邻居数据
    } else {
        // 邻居未加载，跳过或使用默认值
    }
}
```

### 8.2 活跃集合的自动维护

**挑战：**
- 何时添加到活跃集合？
- 何时移除？（避免永久增长）

**解决方案：**
```rust
// 智能激活策略
impl ThermalApi {
    pub fn auto_activate_if_needed(chunk: &mut ChunkData, idx: usize) {
        let temp = Self::get_temp(chunk, idx);
        let default = chunk.voxels[idx].properties().temperature;

        // 条件 1：温度偏离默认值
        if (temp - default).abs() > 1.0 {
            chunk.active_thermal.insert(idx);
            return;
        }

        // 条件 2：周围有热源
        for neighbor in get_neighbors(idx) {
            if chunk.flags[neighbor].contains(VoxelFlags::BURNING) {
                chunk.active_thermal.insert(idx);
                return;
            }
        }

        // 条件 3：周围有温度梯度
        let has_gradient = get_neighbors(idx)
            .iter()
            .any(|&n| (Self::get_temp(chunk, n) - temp).abs() > 5.0);

        if has_gradient {
            chunk.active_thermal.insert(idx);
        } else {
            // 稳定状态，移除
            chunk.active_thermal.remove(&idx);
        }
    }
}
```

### 8.3 性能监控与调优

**监控指标：**
```rust
#[derive(Resource)]
pub struct SimulationStats {
    pub active_thermal_count: usize,
    pub active_burning_count: usize,
    pub commands_per_tick: usize,
    pub avg_commit_time_ms: f32,
}

// 在 Post 阶段收集统计
pub fn stats_collection_system(
    voxel_world: Res<VoxelWorld>,
    mut stats: ResMut<SimulationStats>,
) {
    stats.active_thermal_count = voxel_world.chunks.values()
        .map(|c| c.active_thermal.len())
        .sum();
    // ...
}
```

---

## 九、客户端表现集成

### 9.1 状态到 VFX 的映射

```rust
// src/voxel/vfx.rs

pub fn spawn_fire_particles_system(
    voxel_world: Res<VoxelWorld>,
    mut commands: Commands,
    asset_server: Res<AssetServer>,
) {
    for (chunk_pos, chunk) in voxel_world.chunks.iter() {
        for &idx in &chunk.active_burning {
            if chunk.flags[idx].contains(VoxelFlags::BURNING) {
                let world_pos = chunk_idx_to_world_pos(*chunk_pos, idx);

                // 生成火焰粒子特效
                commands.spawn((
                    ParticleEffect::new(ParticleType::Fire),
                    Transform::from_translation(world_pos),
                ));
            }
        }
    }
}

pub fn update_block_colors_system(
    voxel_world: Res<VoxelWorld>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    for chunk in voxel_world.chunks.values() {
        for (idx, &flags) in chunk.flags.iter().enumerate() {
            // 焦化变黑
            if flags.contains(VoxelFlags::CHARRED) {
                // 修改材质颜色
            }

            // 冻结变蓝
            if flags.contains(VoxelFlags::FROZEN) {
                // 添加冰霜效果
            }

            // 高温发光
            if flags.contains(VoxelFlags::HOT) {
                let temp = ThermalApi::get_temp(chunk, idx);
                if temp > 500.0 {
                    // 添加发光效果
                }
            }
        }
    }
}
```

---

## 十、总结与下一步

### 核心设计原则回顾

1. **Chunk 作为 Entity，方块不是 Entity**
2. **活跃集合驱动，避免全量扫描**
3. **状态分层：通用全量 + 专用稀疏**
4. **领域模块化，统一 Reaction/Command 接口**
5. **固定阶段执行，禁止跨阶段写入**
6. **diff 驱动渲染与网络同步**

### 立即可开始的任务

1. 扩展 `ChunkData`，添加 `flags` 和 `variant`
2. 实现 `VoxelFlags` bitflags
3. 为现有 33 种方块填充完整物理属性
4. 实现 `DomainCommand` 枚举和 `commit_system`
5. 搭建 `SimulationSet` 系统集顺序

### 预期效果

实现后，你将拥有：
- **真实的物理模拟**：火焰传播、水结冰、植物生长
- **多样的玩法可能**：消防、农业、建筑结构、环境改造
- **可扩展的架构**：新增领域线无需修改核心
- **高性能**：活跃集合驱动，只计算必要的部分
- **MMO 就绪**：diff 同步、存档压缩、网络增量更新

---

**此文档作为实施蓝图，建议按 Phase 1 → Phase 2 → Phase 3 逐步迭代。每个 Phase 完成后都应有可玩的 Demo，快速验证设计的正确性。**
